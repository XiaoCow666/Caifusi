“财赋思”项目编程实现蓝图 (Python-Flask & React & Firebase)1. 技术选型回顾后端： Python 3.x + Flask (轻量级，快速开发)前端： React (组件化，生态丰富) + Tailwind CSS (快速UI构建)数据库： Firebase Firestore (NoSQL, 实时同步，易于集成)AI模型API： Google Gemini API (用于AI教练的核心对话能力)版本控制： Git部署（MVP阶段可选）：后端: PythonAnywhere, Google Cloud Run, Heroku前端: Vercel, Netlify, GitHub Pages数据库: Firebase自带2. 项目文件目录结构caifusi_project/
├── backend/
│   ├── app/
│   │   ├── __init__.py             # Flask app 初始化
│   │   ├── config.py               # 配置文件 (API Keys, Firebase config)
│   │   ├── models/                 # 数据模型 (如果不用纯Firestore, 或定义结构)
│   │   │   └── user.py
│   │   ├── routes/                 # API 路由
│   │   │   ├── __init__.py
│   │   │   ├── auth_routes.py        # 用户认证路由
│   │   │   ├── coach_routes.py       # AI教练交互路由
│   │   │   ├── assessment_routes.py  # 心智评估路由
│   │   │   └── content_routes.py     # 知识库等内容路由
│   │   ├── services/               # 业务逻辑服务
│   │   │   ├── __init__.py
│   │   │   ├── auth_service.py
│   │   │   ├── coach_service.py      # 包含Gemini API调用逻辑
│   │   │   ├── assessment_service.py
│   │   │   └── firestore_service.py  # Firebase Firestore 交互封装
│   │   ├── utils/                  # 工具函数
│   │   │   └── helpers.py
│   │   └── templates/              # (可选) 如果后端也渲染部分简单页面
│   │   └── static/                 # (可选) 静态文件
│   ├── venv/                       # Python虚拟环境
│   ├── requirements.txt            # Python依赖
│   ├── run.py                      # Flask启动脚本
│   └── .env                        # 环境变量 (API Keys等，不提交到Git)
│
├── frontend/
│   ├── public/
│   │   ├── index.html
│   │   └── ... (其他静态资源如favicon)
│   ├── src/
│   │   ├── App.js                  # 主应用组件
│   │   ├── index.js                # React应用入口
│   │   ├── reportWebVitals.js
│   │   ├── setupTests.js
│   │   ├── assets/                 # 图片、字体等
│   │   ├── components/             # 通用UI组件
│   │   │   ├── Navbar.js
│   │   │   ├── Button.js
│   │   │   ├── LoadingSpinner.js
│   │   │   └── Modal.js
│   │   ├── contexts/               # React Context (可选, 如 AuthContext)
│   │   │   └── AuthContext.js
│   │   ├── features/               # 按功能模块组织组件
│   │   │   ├── auth/
│   │   │   │   ├── LoginPage.js
│   │   │   │   └── RegisterPage.js
│   │   │   ├── coach/
│   │   │   │   ├── CoachInterface.js
│   │   │   │   └── Message.js
│   │   │   ├── assessment/
│   │   │   │   ├── AssessmentPage.js
│   │   │   │   └── Question.js
│   │   │   ├── growth_path/
│   │   │   │   └── GrowthPathPage.js
│   │   │   ├── toolkit/
│   │   │   │   └── CognitiveBiasTool.js
│   │   │   └── knowledge_base/
│   │   │       └── ArticlePage.js
│   │   ├── services/               # API调用服务
│   │   │   ├── api.js                # Axios实例和通用API函数
│   │   │   ├── authService.js
│   │   │   └── coachService.js
│   │   ├── hooks/                  # 自定义Hooks
│   │   │   └── useAuth.js
│   │   ├── pages/                  # 页面级组件 (另一种组织方式)
│   │   ├── store/                  # 状态管理 (如Zustand)
│   │   │   └── userStore.js
│   │   ├── styles/                 # 全局样式 (如果不用纯Tailwind)
│   │   └── utils/                  # 前端工具函数
│   ├── package.json
│   ├── tailwind.config.js
│   └── postcss.config.js
│
└── README.md
3. 后端实现 (Python - Flask)3.1. backend/app/__init__.py (Flask App 初始化)# backend/app/__init__.py
from flask import Flask
from flask_cors import CORS
from .config import Config
# Firebase Admin SDK for backend operations
import firebase_admin
from firebase_admin import credentials, firestore

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)
    CORS(app) # 允许跨域请求，方便前后端分离开发

    # 初始化 Firebase Admin SDK
    # 你需要从 Firebase 控制台下载你的服务账户密钥 JSON 文件
    # 并将其路径设置在环境变量 FIREBASE_ADMIN_SDK_PATH 中
    # 或者直接在 Config 中指定路径
    try:
        cred = credentials.Certificate(app.config['FIREBASE_ADMIN_SDK_PATH'])
        firebase_admin.initialize_app(cred)
        app.db = firestore.client() # 将 Firestore 客户端附加到 app 对象
        print("Firebase Admin SDK initialized successfully.")
    except Exception as e:
        print(f"Error initializing Firebase Admin SDK: {e}")
        app.db = None # 或者抛出异常，强制修复

    # 注册蓝图 (Blueprints)
    from .routes.auth_routes import auth_bp
    from .routes.coach_routes import coach_bp
    from .routes.assessment_routes import assessment_bp
    # ... 其他蓝图

    app.register_blueprint(auth_bp, url_prefix='/api/auth')
    app.register_blueprint(coach_bp, url_prefix='/api/coach')
    app.register_blueprint(assessment_bp, url_prefix='/api/assessment')
    # ...

    @app.route('/api/health', methods=['GET'])
    def health_check():
        return {"status": "healthy", "firebase_initialized": app.db is not None}, 200

    return app
3.2. backend/app/config.py# backend/app/config.py
import os
from dotenv import load_dotenv

load_dotenv() # 加载 .env 文件中的环境变量

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'your-secret-key'
    GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')
    FIREBASE_ADMIN_SDK_PATH = os.environ.get('FIREBASE_ADMIN_SDK_PATH') # e.g., "path/to/your/serviceAccountKey.json"
    # Firebase Web SDK config (如果前端需要直接与Firebase交互，通常后端用Admin SDK)
    # FIREBASE_CONFIG = {
    #     "apiKey": os.environ.get("FIREBASE_API_KEY"),
    #     "authDomain": os.environ.get("FIREBASE_AUTH_DOMAIN"),
    #     "projectId": os.environ.get("FIREBASE_PROJECT_ID"),
    #     "storageBucket": os.environ.get("FIREBASE_STORAGE_BUCKET"),
    #     "messagingSenderId": os.environ.get("FIREBASE_MESSAGING_SENDER_ID"),
    #     "appId": os.environ.get("FIREBASE_APP_ID")
    # }
.env 文件示例 (在 backend/ 目录下, 不要提交到Git):SECRET_KEY=a_very_strong_random_secret_key
GEMINI_API_KEY=your_gemini_api_key_here
FIREBASE_ADMIN_SDK_PATH=./path_to_your_firebase_service_account.json
3.3. backend/app/services/firestore_service.py (Firestore 交互)# backend/app/services/firestore_service.py
from flask import current_app

# --- Firestore Global Variables (Provided by Canvas Environment) ---
# These are placeholders. In a real Canvas environment, these would be injected.
# For local development, you'd typically use environment variables or a config file.
__app_id = 'default-app-id' # Replace with actual __app_id if provided by environment
# __firebase_config is typically a JSON string for client-side SDK,
# Admin SDK uses a service account key.

def get_db():
    """Helper function to get the Firestore client instance."""
    if not hasattr(current_app, 'db') or current_app.db is None:
        # This indicates Firebase Admin SDK was not initialized correctly.
        # In a real app, you might want to raise an error or try re-initializing.
        print("Firestore client (current_app.db) is not available.")
        return None
    return current_app.db

def get_user_collection_path(user_id, collection_name):
    """Constructs the path for a user's private collection."""
    app_id = getattr(current_app, '__app_id', __app_id) # Use app_id from current_app if set
    return f"artifacts/{app_id}/users/{user_id}/{collection_name}"

def get_public_collection_path(collection_name):
    """Constructs the path for a public collection."""
    app_id = getattr(current_app, '__app_id', __app_id)
    return f"artifacts/{app_id}/public/data/{collection_name}"

# --- User Management ---
def create_user_profile(user_id, email, display_name=""):
    """Creates a new user profile document in Firestore."""
    db = get_db()
    if not db: return None, "Firestore not initialized"
    try:
        user_profile_ref = db.collection(get_user_collection_path(user_id, "profile")).document(user_id)
        user_profile_ref.set({
            "email": email,
            "displayName": display_name or email.split('@')[0],
            "createdAt": firestore.SERVER_TIMESTAMP,
            "lastLogin": firestore.SERVER_TIMESTAMP,
            "assessmentCompleted": False,
            "goals": [] # Example: [{ "id": "goal1", "description": "Save for travel", "targetAmount": 1000, "currentAmount": 0 }]
        })
        return user_profile_ref.id, None
    except Exception as e:
        return None, str(e)

def get_user_profile(user_id):
    """Retrieves a user profile from Firestore."""
    db = get_db()
    if not db: return None, "Firestore not initialized"
    try:
        user_ref = db.collection(get_user_collection_path(user_id, "profile")).document(user_id)
        user_doc = user_ref.get()
        if user_doc.exists:
            return user_doc.to_dict(), None
        else:
            return None, "User not found"
    except Exception as e:
        return None, str(e)

def update_user_profile(user_id, data_to_update):
    """Updates a user profile in Firestore."""
    db = get_db()
    if not db: return None, "Firestore not initialized"
    try:
        # Ensure lastLogin is updated if not explicitly provided
        if "lastLogin" not in data_to_update:
            data_to_update["lastLogin"] = firestore.SERVER_TIMESTAMP

        user_ref = db.collection(get_user_collection_path(user_id, "profile")).document(user_id)
        user_ref.update(data_to_update)
        return True, None
    except Exception as e:
        return False, str(e)

# --- Assessment Data ---
def save_assessment_results(user_id, assessment_data):
    """Saves assessment results for a user."""
    db = get_db()
    if not db: return None, "Firestore not initialized"
    try:
        # Example: assessment_data = {"risk_profile": "moderate", "biases": ["confirmation_bias"]}
        assessment_ref = db.collection(get_user_collection_path(user_id, "assessments")).document("latest") # Or use a timestamped ID
        assessment_ref.set({
            **assessment_data,
            "completedAt": firestore.SERVER_TIMESTAMP
        })
        # Update user profile to mark assessment as completed
        update_user_profile(user_id, {"assessmentCompleted": True})
        return assessment_ref.id, None
    except Exception as e:
        return None, str(e)

def get_assessment_results(user_id):
    """Retrieves the latest assessment results for a user."""
    db = get_db()
    if not db: return None, "Firestore not initialized"
    try:
        doc_ref = db.collection(get_user_collection_path(user_id, "assessments")).document("latest")
        doc = doc_ref.get()
        if doc.exists:
            return doc.to_dict(), None
        return None, "Assessment not found"
    except Exception as e:
        return None, str(e)

# --- Coach Conversations ---
def save_coach_message(user_id, message_data):
    """Saves a message from/to the AI coach."""
    db = get_db()
    if not db: return None, "Firestore not initialized"
    try:
        # message_data = {"sender": "user" or "ai", "text": "message content", "timestamp": firestore.SERVER_TIMESTAMP}
        # Store conversations in a subcollection for better querying if needed, or as an array in a single doc for simplicity
        # For longer conversations, a subcollection is better.
        # Path: artifacts/{app_id}/users/{user_id}/coach_conversations/{conversation_id}/messages/{message_id}
        # Or simpler: artifacts/{app_id}/users/{user_id}/coach_log (array of messages) - less scalable
        
        # Using a simple log in user's profile for MVP, but subcollection is better for production
        # This example appends to an array in the user's profile document.
        # This is NOT recommended for long conversations due to document size limits (1MB).
        # A dedicated 'coach_conversations' collection per user is better.
        
        # Let's assume a dedicated collection for messages:
        # artifacts/{app_id}/users/{user_id}/coach_messages/
        
        # Ensure timestamp is set
        if "timestamp" not in message_data:
            message_data["timestamp"] = firestore.SERVER_TIMESTAMP

        msg_ref = db.collection(get_user_collection_path(user_id, "coach_messages")).add(message_data)
        return msg_ref[1].id, None # add() returns a tuple (timestamp, DocumentReference)
    except Exception as e:
        return None, str(e)

def get_coach_history(user_id, limit=20):
    """Retrieves the last N messages from the AI coach conversation."""
    db = get_db()
    if not db: return [], "Firestore not initialized"
    try:
        messages_ref = db.collection(get_user_collection_path(user_id, "coach_messages"))
        # Order by timestamp descending to get the latest messages
        # Note: Firestore requires a composite index for queries with orderBy and filters on different fields.
        # For simple orderBy on timestamp, it might work without explicit index if it's the only filter.
        # However, it's good practice to create indexes.
        # For MVP, if orderBy causes issues without an index, fetch and sort in Python, or ensure an index exists.
        # query = messages_ref.order_by("timestamp", direction=firestore.Query.DESCENDING).limit(limit)
        
        # Simpler fetch for MVP if ordering is an issue without pre-configured indexes:
        # Fetch all and sort in code (not efficient for large datasets)
        # For now, let's assume an index on "timestamp" exists or we sort client-side/app-side.
        # For robust ordering, ensure your Firestore has the necessary indexes.
        # For MVP, let's try without explicit orderBy to avoid index issues in a fresh setup.
        # You would typically sort this on the client or after fetching if not using orderBy.
        
        # Correct way with ordering (requires index on 'timestamp'):
        query = messages_ref.order_by("timestamp", direction=firestore.Query.DESCENDING).limit(limit)
        docs = query.stream()
        
        history = []
        for doc in docs:
            msg = doc.to_dict()
            msg["id"] = doc.id
            history.append(msg)
        return list(reversed(history)), None # Reverse to get chronological order (oldest to newest)
    except Exception as e:
        # Fallback if ordering fails (e.g., missing index) - fetch without order and sort later
        print(f"Error fetching coach history with ordering: {e}. Trying without explicit order.")
        try:
            docs = messages_ref.limit(limit).stream() # No specific order
            history = []
            for doc in docs:
                msg = doc.to_dict()
                msg["id"] = doc.id
                history.append(msg)
            # Sort by timestamp in Python (if timestamp is a proper Firestore Timestamp or comparable)
            history.sort(key=lambda x: x.get("timestamp"))
            return history, None
        except Exception as e_fallback:
            return [], str(e_fallback)


# --- Knowledge Base (Public Data Example) ---
def add_kb_article(article_data):
    """Adds a new article to the public knowledge base."""
    db = get_db()
    if not db: return None, "Firestore not initialized"
    try:
        # article_data = {"title": "Understanding ETFs", "content": "...", "category": "Investing", "tags": ["etf", "stocks"]}
        article_data["createdAt"] = firestore.SERVER_TIMESTAMP
        article_ref = db.collection(get_public_collection_path("knowledge_base")).add(article_data)
        return article_ref[1].id, None
    except Exception as e:
        return None, str(e)

def get_kb_articles(category=None, limit=10):
    """Retrieves articles from the public knowledge base."""
    db = get_db()
    if not db: return [], "Firestore not initialized"
    try:
        articles_ref = db.collection(get_public_collection_path("knowledge_base"))
        query = articles_ref
        if category:
            query = query.where("category", "==", category) # Requires index on 'category'
        
        # Add ordering if needed, e.g., by createdAt (requires index)
        # query = query.order_by("createdAt", direction=firestore.Query.DESCENDING)
        
        docs = query.limit(limit).stream()
        articles = []
        for doc in docs:
            article = doc.to_dict()
            article["id"] = doc.id
            articles.append(article)
        return articles, None
    except Exception as e:
        return [], str(e)

# You would add more functions here for other data types:
# - Goals (CRUD)
# - Financial Tools Data (e.g., budget templates, savings plans)
# - User Feedback
3.4. backend/app/services/auth_service.py (用户认证逻辑)功能： 处理用户注册、登录、登出、密码管理（如果使用Firebase Auth，很多由Firebase处理）。实现思路：Firebase Auth (推荐): 前端使用Firebase Web SDK进行注册/登录，获取ID Token。后端接收ID Token，使用Firebase Admin SDK验证Token，获取用户UID。如果自建认证 (不推荐，更复杂): 密码哈希存储 (e.g., Werkzeug security)，Session管理或JWT。create_user_profile: 在用户首次通过Firebase Auth认证并访问后端时，在Firestore中创建对应的用户profile。# backend/app/services/auth_service.py
from firebase_admin import auth
from .firestore_service import create_user_profile, get_user_profile, update_user_profile

def verify_firebase_token(id_token):
    """Verifies Firebase ID token and returns user info."""
    try:
        decoded_token = auth.verify_id_token(id_token)
        uid = decoded_token['uid']
        email = decoded_token.get('email')
        
        # Check if user profile exists in Firestore, create if not
        profile, error = get_user_profile(uid)
        if error and "User not found" in error: # Be careful with string matching for errors
            profile_id, create_error = create_user_profile(uid, email)
            if create_error:
                return None, f"Failed to create user profile: {create_error}"
            profile, _ = get_user_profile(uid) # Fetch again
        elif error:
            return None, f"Error fetching user profile: {error}"
        else:
            # Update last login time
            _, update_error = update_user_profile(uid, {"lastLogin": auth.firestore.SERVER_TIMESTAMP})
            if update_error:
                print(f"Warning: Failed to update last login for user {uid}: {update_error}")


        return {"uid": uid, "email": email, "profile": profile}, None
    except auth.InvalidIdTokenError:
        return None, "Invalid ID token"
    except Exception as e:
        return None, str(e)

# If you were to implement custom registration (not recommended with Firebase Auth for client):
# def register_user_custom(email, password):
#     try:
#         # This is for creating users directly via Admin SDK, typically client SDK handles this
#         user = auth.create_user(email=email, password=password)
#         # Create profile in Firestore
#         profile_id, error = create_user_profile(user.uid, email)
#         if error:
#             # Potentially delete the Firebase Auth user if profile creation fails, or handle inconsistency
#             auth.delete_user(user.uid)
#             return None, f"Failed to create user profile: {error}"
#         return {"uid": user.uid, "email": user.email}, None
#     except Exception as e:
#         return None, str(e)
3.5. backend/app/routes/auth_routes.py# backend/app/routes/auth_routes.py
from flask import Blueprint, request, jsonify
from app.services.auth_service import verify_firebase_token
# from app.services.firestore_service import get_user_profile # Already handled in verify_firebase_token

auth_bp = Blueprint('auth_bp', __name__)

@auth_bp.route('/verify_token', methods=['POST'])
def verify_token_route():
    """
    Endpoint for frontend to send Firebase ID token for verification.
    This can also serve as a login/session creation endpoint.
    """
    data = request.get_json()
    id_token = data.get('idToken')

    if not id_token:
        return jsonify({"error": "ID token is required"}), 400

    user_info, error = verify_firebase_token(id_token)

    if error:
        return jsonify({"error": error}), 401 # Unauthorized or Bad Request depending on error

    # Token verified, user_info contains uid, email, and profile
    # You might want to set a session cookie here if using traditional sessions,
    # or just rely on the frontend to keep sending the ID token for authenticated requests.
    # For simplicity, we'll assume frontend sends token with each request.
    return jsonify({"message": "Token verified successfully", "user": user_info}), 200

# Example: Get current user profile (requires token)
@auth_bp.route('/me', methods=['GET'])
def get_current_user():
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({"error": "Authorization token is required"}), 401
    
    id_token = auth_header.split('Bearer ')[1]
    user_info, error = verify_firebase_token(id_token) # Verifies and fetches profile

    if error:
        return jsonify({"error": f"Authentication failed: {error}"}), 401
    
    # user_info already contains the profile from Firestore
    return jsonify({"user": user_info.get("profile", {})}), 200

3.6. backend/app/services/coach_service.py (AI教练核心逻辑)# backend/app/services/coach_service.py
import google.generativeai as genai
from flask import current_app
from .firestore_service import save_coach_message, get_coach_history

def configure_gemini():
    """Configures the Gemini API key."""
    api_key = current_app.config.get('GEMINI_API_KEY')
    if not api_key:
        raise ValueError("GEMINI_API_KEY not configured.")
    genai.configure(api_key=api_key)

def generate_coach_response(user_id, user_message_text, context_type="general_chat"):
    """
    Generates a response from the AI coach using Gemini.
    Saves user message and AI response to Firestore.
    """
    try:
        configure_gemini() # Ensure Gemini is configured
    except ValueError as e:
        return f"AI Coach configuration error: {e}", True # True indicates an error

    # 1. Save user's message to history
    _, error = save_coach_message(user_id, {"sender": "user", "text": user_message_text})
    if error:
        print(f"Error saving user message for {user_id}: {error}")
        # Decide if you want to proceed without saving or return an error

    # 2. Retrieve recent conversation history (optional, but good for context)
    history_messages, history_error = get_coach_history(user_id, limit=10) # Get last 10 messages (user and AI)
    if history_error:
        print(f"Warning: Could not retrieve chat history for {user_id}: {history_error}")
        # Proceed without history or handle error

    # 3. Construct prompt for Gemini
    # Prompt Engineering is CRITICAL here.
    # Base prompt defining the AI's persona and role.
    base_prompt = (
        "你是一位名叫“财赋思”的AI金融心智教练。你的目标是帮助用户提升金融素养，"
        "识别并克服常见的金融认知偏差，培养健康的理财习惯，并以友好、耐心、专业的态度提供个性化指导。"
        "请避免直接给出投资建议（例如“购买某某股票”），而是侧重于教育用户如何思考和决策。\n\n"
    )

    # Add context from conversation history
    formatted_history = []
    if history_messages:
        for msg in history_messages:
            role = "user" if msg.get("sender") == "user" else "model" # Gemini uses 'user' and 'model'
            # Ensure 'parts' is a list of dictionaries with 'text'
            formatted_history.append({"role": role, "parts": [{"text": msg.get("text", "")}]})
    
    # Add current user message to the history for the prompt
    # The API expects the current user message as the last 'user' part.
    # If history is empty, formatted_history will be empty.
    # The final prompt to generateContent will be `formatted_history` (which includes past turns)
    # followed by the new user message part.

    # Construct the payload for generateContent
    # Gemini API expects `contents` to be a list of turns, where each turn has a role and parts.
    # The last part should be the current user's message.
    
    # Start with the base persona if no history or as a system instruction (depends on model)
    # For gemini-pro, you can prepend system instructions or include them in the first user turn.
    # A more robust way is to use system_instruction if the model supports it.
    # For now, let's prepend to the history or first user message.

    # Create the full list of contents for the API call
    api_contents = []
    # Add persona/system instruction (if not using dedicated system_instruction field)
    # One way: Treat the base_prompt as a system message or part of the first user message context.
    # For conversational models, it's often better to let the history build naturally.
    # Let's try adding it as context to the first message or as a "system" role if supported.
    # Gemini's `generateContent` with `contents` typically alternates user/model.

    # If there's history, prepend our base_prompt to the history or ensure it's implicitly understood.
    # For simplicity, we'll add it to the user's current message context for this call.
    # A better approach for long-term context is to use a specific system prompt mechanism if available
    # or fine-tune a model.

    # Let's build the `contents` for the API call
    # `formatted_history` already contains past user/model messages
    # The new user message should be the last item.
    
    current_user_turn = {"role": "user", "parts": [{"text": base_prompt + "\n---对话历史---\n" + user_message_text if not formatted_history else user_message_text}]}

    if not formatted_history:
        # If no history, the current user message is the start, include base prompt
        api_contents = [current_user_turn]
    else:
        api_contents = formatted_history + [current_user_turn]


    # For specific context_types, you can add more instructions:
    if context_type == "assessment_feedback":
        # (Assume assessment_results are fetched and passed here)
        # prompt += f"\n用户刚完成了金融心智评估，结果显示[相关结果]。请基于此提供初步反馈和鼓励。"
        pass # Add specific instructions to the current_user_turn.parts[0].text
    elif context_type == "decision_support_spending":
        # prompt += f"\n用户正在考虑一笔消费，请帮助TA分析，并注意提醒可能的冲动消费或认知偏差。"
        pass

    try:
        # model = genai.GenerativeModel('gemini-pro') # Or other suitable model like gemini-1.5-flash
        # Using gemini-2.0-flash as per instructions
        model = genai.GenerativeModel('gemini-2.0-flash')
        
        # print(f"DEBUG: Sending to Gemini API. Contents: {api_contents}")

        response = model.generate_content(
            api_contents,
            # generation_config=genai.types.GenerationConfig(...) # Optional: temperature, top_k, etc.
        )
        
        # print(f"DEBUG: Gemini API Response: {response}")

        ai_response_text = ""
        if response.candidates and response.candidates[0].content and response.candidates[0].content.parts:
             ai_response_text = "".join(part.text for part in response.candidates[0].content.parts)
        else:
            # Handle cases where the response structure is unexpected or content is missing
            # Check response.prompt_feedback for blocked prompts
            if response.prompt_feedback:
                print(f"DEBUG: Prompt Feedback: {response.prompt_feedback}")
                ai_response_text = "抱歉，我无法回答这个问题。可能触发了安全设置。"
            else:
                ai_response_text = "抱歉，AI教练暂时无法回应，请稍后再试。"


    except Exception as e:
        print(f"Error calling Gemini API: {e}")
        ai_response_text = "抱歉，AI教练遇到技术问题，请稍后再试。"
        # 4. Save AI's error response to history
        save_coach_message(user_id, {"sender": "ai", "text": ai_response_text, "error": True})
        return ai_response_text, True

    # 4. Save AI's response to history
    _, error = save_coach_message(user_id, {"sender": "ai", "text": ai_response_text})
    if error:
        print(f"Error saving AI response for {user_id}: {error}")
        # Decide how to handle this, the user already got the response

    return ai_response_text, False # False indicates no error in generation
3.7. backend/app/routes/coach_routes.py# backend/app/routes/coach_routes.py
from flask import Blueprint, request, jsonify
from app.services.coach_service import generate_coach_response, get_coach_history
from app.services.auth_service import verify_firebase_token # To get authenticated user_id

coach_bp = Blueprint('coach_bp', __name__)

@coach_bp.route('/chat', methods=['POST'])
def chat_with_coach():
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({"error": "Authorization token is required"}), 401
    
    id_token = auth_header.split('Bearer ')[1]
    user_auth_info, auth_error = verify_firebase_token(id_token)

    if auth_error:
        return jsonify({"error": f"Authentication failed: {auth_error}"}), 401
    
    user_id = user_auth_info['uid']
    
    data = request.get_json()
    user_message = data.get('message')
    context_type = data.get('context_type', "general_chat") # Optional: for more specific prompts

    if not user_message:
        return jsonify({"error": "Message is required"}), 400

    ai_response, error_occurred = generate_coach_response(user_id, user_message, context_type)

    if error_occurred:
        # The error message is already formatted for the user within ai_response
        return jsonify({"reply": ai_response, "error": True}), 500 
        
    return jsonify({"reply": ai_response, "error": False}), 200

@coach_bp.route('/history', methods=['GET'])
def get_chat_history():
    auth_header = request.headers.get('Authorization')
    if not auth_header or not auth_header.startswith('Bearer '):
        return jsonify({"error": "Authorization token is required"}), 401
    
    id_token = auth_header.split('Bearer ')[1]
    user_auth_info, auth_error = verify_firebase_token(id_token)

    if auth_error:
        return jsonify({"error": f"Authentication failed: {auth_error}"}), 401
        
    user_id = user_auth_info['uid']
    limit = request.args.get('limit', 20, type=int)

    history, error = get_coach_history(user_id, limit=limit)
    if error:
        return jsonify({"error": error, "history": []}), 500
        
    return jsonify({"history": history}), 200
3.8. backend/app/services/assessment_service.py功能： 定义评估问卷题目，计算评估结果（如风险偏好、认知偏差倾向）。实现思路：题目可以硬编码或从Firestore加载（如果希望动态更新）。评估逻辑：根据用户答案，按预设规则打分或分类。结果存储到firestore_service.save_assessment_results。3.9. backend/app/routes/assessment_routes.py/api/assessment/questions (GET): 返回评估问卷题目。**/api/assessment/submit (POST):**接收用户答案，调用assessment_service处理，保存结果，返回评估摘要。3.10. backend/run.py# backend/run.py
from app import create_app

app = create_app()

if __name__ == '__main__':
    # For development, Flask's built-in server is fine.
    # For production, use a WSGI server like Gunicorn or uWSGI.
    # Example: gunicorn -w 4 -b 0.0.0.0:5001 run:app (port 5001 to avoid conflict with React dev server)
    app.run(debug=True, port=5001)
4. 前端实现 (React)4.1. frontend/src/App.js// frontend/src/App.js
import React, { useState, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { getAuth, onAuthStateChanged, signOut as firebaseSignOut } from 'firebase/auth';
import { initializeApp } from 'firebase/app'; // Firebase app

// Firebase Config (should be in a .env file and imported)
// Ensure these are set in your .env.local or similar
const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.REACT_APP_FIREBASE_APP_ID,
};

// Initialize Firebase
const firebaseApp = initializeApp(firebaseConfig);
const auth = getAuth(firebaseApp); // Get auth instance

// Import Pages and Components
import Navbar from './components/Navbar';
import LoginPage from './features/auth/LoginPage';
import RegisterPage from './features/auth/RegisterPage';
import CoachInterface from './features/coach/CoachInterface';
import AssessmentPage from './features/assessment/AssessmentPage';
import GrowthPathPage from './features/growth_path/GrowthPathPage';
import KnowledgeBasePage from './features/knowledge_base/KnowledgeBasePage'; // Placeholder
import UserDashboard from './pages/UserDashboard'; // Placeholder for a dashboard page
import HomePage from './pages/HomePage'; // Placeholder for a landing/home page
import { AuthProvider, useAuth } from './contexts/AuthContext'; // Auth context
import LoadingSpinner from './components/LoadingSpinner';

// ProtectedRoute component
const ProtectedRoute = ({ children }) => {  
  const { currentUser, loadingAuth } = useAuth();
  if (loadingAuth) {
    return <div className="flex justify-center items-center h-screen"><LoadingSpinner /></div>;
  }
  return currentUser ? children : <Navigate to="/login" />;
};


function AppContent() {
  const { currentUser, loadingAuth, idToken } = useAuth();

  if (loadingAuth) {
    return <div className="flex justify-center items-center h-screen"><LoadingSpinner /></div>;
  }

  return (
    <Router>
      <Navbar />
      <main className="container mx-auto p-4 mt-16"> {/* Add margin-top for fixed navbar */}
        <Routes>
          <Route path="/" element={currentUser ? <Navigate to="/dashboard" /> : <HomePage />} />
          <Route path="/login" element={!currentUser ? <LoginPage /> : <Navigate to="/dashboard" />} />
          <Route path="/register" element={!currentUser ? <RegisterPage /> : <Navigate to="/dashboard" />} />
          
          <Route 
            path="/dashboard" 
            element={<ProtectedRoute><UserDashboard /></ProtectedRoute>} 
          />
          <Route 
            path="/coach" 
            element={<ProtectedRoute><CoachInterface /></ProtectedRoute>} 
          />
          <Route 
            path="/assessment" 
            element={<ProtectedRoute><AssessmentPage /></ProtectedRoute>} 
          />
          <Route 
            path="/growth-path" 
            element={<ProtectedRoute><GrowthPathPage /></ProtectedRoute>} 
          />
           <Route 
            path="/knowledge" 
            element={<ProtectedRoute><KnowledgeBasePage /></ProtectedRoute>} 
          />
          {/* Add more routes as needed */}
          <Route path="*" element={<Navigate to={currentUser ? "/dashboard" : "/"} />} />
        </Routes>
      </main>
    </Router>
  );
}

function App() {
  return (
    <AuthProvider firebaseAuth={auth}> {/* Pass auth instance to AuthProvider */}
      <AppContent />
    </AuthProvider>
  );
}

export default App;
4.2. frontend/src/contexts/AuthContext.js// frontend/src/contexts/AuthContext.js
import React, { createContext, useContext, useState, useEffect } from 'react';
import { onAuthStateChanged, signOut as firebaseSignOut } from 'firebase/auth';
import api from '../services/api'; // Your Axios instance

const AuthContext = createContext();

export function useAuth() {
  return useContext(AuthContext);
}

export function AuthProvider({ children, firebaseAuth }) { // Accept firebaseAuth as a prop
  const [currentUser, setCurrentUser] = useState(null);
  const [idToken, setIdToken] = useState(null);
  const [loadingAuth, setLoadingAuth] = useState(true);
  const [serverProfile, setServerProfile] = useState(null); // Profile from your backend

  useEffect(() => {
    if (!firebaseAuth) {
        console.error("Firebase Auth instance not provided to AuthProvider.");
        setLoadingAuth(false);
        return;
    }
    const unsubscribe = onAuthStateChanged(firebaseAuth, async (user) => {
      setCurrentUser(user);
      if (user) {
        try {
          const token = await user.getIdToken();
          setIdToken(token);
          // Verify token with backend and get server-side profile
          const response = await api.post('/auth/verify_token', { idToken: token });
          setServerProfile(response.data.user.profile); // Assuming this structure
          // Store token in api instance for subsequent requests
          api.defaults.headers.common['Authorization'] = `Bearer ${token}`;
        } catch (error) {
          console.error("Error verifying token or fetching server profile:", error);
          // Handle error, e.g., sign out user if token verification fails
          await firebaseSignOut(firebaseAuth);
          setCurrentUser(null);
          setIdToken(null);
          setServerProfile(null);
          delete api.defaults.headers.common['Authorization'];
        }
      } else {
        setIdToken(null);
        setServerProfile(null);
        delete api.defaults.headers.common['Authorization'];
      }
      setLoadingAuth(false);
    });

    return unsubscribe;
  }, [firebaseAuth]);

  const signOut = async () => {
    setLoadingAuth(true);
    try {
      await firebaseSignOut(firebaseAuth);
      setCurrentUser(null);
      setIdToken(null);
      setServerProfile(null);
      delete api.defaults.headers.common['Authorization'];
    } catch (error) {
      console.error("Error signing out:", error);
    } finally {
      setLoadingAuth(false);
    }
  };


  const value = {
    currentUser,
    idToken,
    loadingAuth,
    serverProfile,
    setServerProfile, // Allow updating server profile after assessment etc.
    signOut,
    // You might add login/register functions here if not using FirebaseUI or custom pages
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}
4.3. frontend/src/services/api.js (Axios setup)// frontend/src/services/api.js
import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:5001/api';

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Interceptor to add Authorization token if available (handled in AuthContext now)
// api.interceptors.request.use(async (config) => {
//   // const token = await getAuthToken(); // Function to get token from AuthContext or localStorage
//   // if (token) {
//   //   config.headers.Authorization = `Bearer ${token}`;
//   // }
//   return config;
// });

export default api;
.env.local 文件示例 (在 frontend/ 目录下):REACT_APP_API_BASE_URL=http://localhost:5001/api

REACT_APP_FIREBASE_API_KEY=your_firebase_web_api_key
REACT_APP_FIREBASE_AUTH_DOMAIN=your_project_id.firebaseapp.com
REACT_APP_FIREBASE_PROJECT_ID=your_project_id
REACT_APP_FIREBASE_STORAGE_BUCKET=your_project_id.appspot.com
REACT_APP_FIREBASE_MESSAGING_SENDER_ID=your_sender_id
REACT_APP_FIREBASE_APP_ID=your_app_id
4.4. frontend/src/features/auth/LoginPage.js功能： 提供登录表单，使用 Firebase Auth (e.g., signInWithEmailAndPassword 或 Google Sign-In)。成功后： AuthContext 会自动处理ID Token并与后端通信。// frontend/src/features/auth/LoginPage.js
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { getAuth, signInWithEmailAndPassword, GoogleAuthProvider, signInWithPopup } from 'firebase/auth';
import { useAuth } from '../../contexts/AuthContext'; // Assuming useAuth provides firebaseAuth

const LoginPage = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();
  const firebaseAuth = getAuth(); // Get auth instance directly

  const handleLogin = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);
    try {
      await signInWithEmailAndPassword(firebaseAuth, email, password);
      // AuthContext will handle token verification with backend
      navigate('/dashboard'); // Or wherever AuthContext redirects after successful login
    } catch (err) {
      setError(err.message);
      console.error("Login error:", err);
    }
    setLoading(false);
  };

  const handleGoogleSignIn = async () => {
    setError('');
    setLoading(true);
    const provider = new GoogleAuthProvider();
    try {
      await signInWithPopup(firebaseAuth, provider);
      // AuthContext will handle token verification
      navigate('/dashboard');
    } catch (err) {
      setError(err.message);
      console.error("Google Sign-In error:", err);
    }
    setLoading(false);
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-100">
      <div className="bg-white p-8 rounded-lg shadow-md w-full max-w-md">
        <h2 className="text-2xl font-bold mb-6 text-center text-gray-800">登录财赋思</h2>
        {error && <p className="bg-red-100 text-red-700 p-3 rounded mb-4">{error}</p>}
        <form onSubmit={handleLogin}>
          <div className="mb-4">
            <label className="block text-gray-700 text-sm font-bold mb-2" htmlFor="email">
              邮箱
            </label>
            <input
              type="email"
              id="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
              required
            />
          </div>
          <div className="mb-6">
            <label className="block text-gray-700 text-sm font-bold mb-2" htmlFor="password">
              密码
            </label>
            <input
              type="password"
              id="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline"
              required
            />
          </div>
          <div className="flex items-center justify-between mb-6">
            <button
              type="submit"
              disabled={loading}
              className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline disabled:opacity-50"
            >
              {loading ? '登录中...' : '登录'}
            </button>
            <Link to="/register" className="inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800">
              没有账户？注册
            </Link>
          </div>
        </form>
        <div className="mt-6">
          <button
            onClick={handleGoogleSignIn}
            disabled={loading}
            className="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded w-full focus:outline-none focus:shadow-outline disabled:opacity-50"
          >
            {loading ? '处理中...' : '使用Google登录'}
          </button>
        </div>
      </div>
    </div>
  );
};

export default LoginPage;
RegisterPage.js 类似，使用 createUserWithEmailAndPassword。4.5. frontend/src/features/coach/CoachInterface.js功能： 显示聊天历史，用户输入框，发送消息到后端 /api/coach/chat，更新聊天界面。实现思路：useState 管理输入框内容、聊天消息列表、加载状态。useEffect 加载历史聊天记录 (调用 /api/coach/history)。发送消息后，乐观更新UI（显示用户消息），然后显示AI回复。// frontend/src/features/coach/CoachInterface.js
import React, { useState, useEffect, useRef } from 'react';
import { useAuth } from '../../contexts/AuthContext';
import api from '../../services/api'; // Your Axios instance
import LoadingSpinner from '../../components/LoadingSpinner';

const CoachInterface = () => {
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const { idToken, currentUser } = useAuth(); // For user identification if needed, token is auto-sent by api instance
  const messagesEndRef = useRef(null); // To scroll to bottom

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(scrollToBottom, [messages]);

  // Fetch chat history on component mount
  useEffect(() => {
    const fetchHistory = async () => {
      if (!idToken) return; // Wait for token
      setIsLoading(true);
      setError('');
      try {
        // API instance already has token in headers from AuthContext
        const response = await api.get('/coach/history');
        setMessages(response.data.history || []);
      } catch (err) {
        console.error("Error fetching chat history:", err);
        setError('无法加载聊天记录。');
      }
      setIsLoading(false);
    };
    fetchHistory();
  }, [idToken]); // Re-fetch if token changes (e.g., re-login)

  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!newMessage.trim()) return;

    const userMessage = {
      id: `temp-user-${Date.now()}`, // Temporary ID for optimistic update
      sender: 'user',
      text: newMessage,
      timestamp: new Date().toISOString(), // Or use Firestore server timestamp if possible
    };
    setMessages(prevMessages => [...prevMessages, userMessage]);
    setNewMessage('');
    setIsLoading(true);
    setError('');

    try {
      // API instance already has token in headers
      const response = await api.post('/coach/chat', { message: userMessage.text });
      const aiReply = response.data.reply;
      
      setMessages(prevMessages => [
        ...prevMessages.filter(msg => msg.id !== userMessage.id), // Remove temp user message
        { ...userMessage, id: response.data.userMessageId || userMessage.id }, // Update with actual ID if backend returns it
        { 
          id: `ai-${Date.now()}`, // Or use ID from backend if provided
          sender: 'ai', 
          text: aiReply, 
          timestamp: new Date().toISOString() // Or use server timestamp
        }
      ]);
    } catch (err) {
      console.error("Error sending message:", err);
      const errorMsg = err.response?.data?.reply || err.response?.data?.error || '发送消息失败，请稍后再试。';
      setError(errorMsg);
      // Add an error message to chat
      setMessages(prevMessages => [
        ...prevMessages,
        { id: `error-${Date.now()}`, sender: 'system', text: errorMsg, timestamp: new Date().toISOString() }
      ]);
    }
    setIsLoading(false);
  };

  // Simple display, can be improved with Message component
  const renderMessage = (msg) => (
    <div 
      key={msg.id || msg.timestamp} 
      className={`p-3 my-2 rounded-lg max-w-xl break-words ${
        msg.sender === 'user' ? 'bg-blue-500 text-white self-end ml-auto' : 
        msg.sender === 'ai' ? 'bg-gray-200 text-gray-800 self-start mr-auto' :
        'bg-red-100 text-red-700 self-center mx-auto text-sm' // System/Error message
      }`}
    >
      <p className="text-sm">{msg.text}</p>
      {/* Optional: Display timestamp */}
      {/* <span className="text-xs opacity-70 block mt-1">
        {new Date(msg.timestamp).toLocaleTimeString()}
      </span> */}
    </div>
  );

  return (
    <div className="flex flex-col h-[calc(100vh-8rem)] max-w-3xl mx-auto bg-white shadow-xl rounded-lg">
      <div className="p-4 border-b">
        <h2 className="text-xl font-semibold text-gray-700">与财赋思教练对话</h2>
      </div>
      <div className="flex-grow p-4 overflow-y-auto space-y-2 flex flex-col">
        {isLoading && messages.length === 0 && <div className="m-auto"><LoadingSpinner /></div>}
        {messages.map(renderMessage)}
        <div ref={messagesEndRef} /> {/* Anchor for scrolling */}
      </div>
      {error && <p className="p-2 text-center text-red-500 bg-red-100">{error}</p>}
      <form onSubmit={handleSendMessage} className="p-4 border-t flex">
        <input
          type="text"
          value={newMessage}
          onChange={(e) => setNewMessage(e.target.value)}
          placeholder="输入你的问题或想法..."
          className="flex-grow p-3 border rounded-l-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          disabled={isLoading && messages.length > 0} // Disable input when AI is replying after initial load
        />
        <button
          type="submit"
          disabled={isLoading && messages.length > 0}
          className="bg-blue-500 text-white p-3 rounded-r-lg hover:bg-blue-600 focus:outline-none disabled:opacity-50"
        >
          发送
        </button>
      </form>
    </div>
  );
};

export default CoachInterface;
4.6. frontend/src/features/assessment/AssessmentPage.js功能： 从后端获取问卷题目，分步显示，收集用户答案，提交到后端 /api/assessment/submit。实现思路：useState 管理当前题目索引、用户答案、加载状态。useEffect 加载问卷题目。4.7. 其他前端组件Navbar.js: 导航栏，包含登录/注册/登出链接，以及指向各功能模块的链接。GrowthPathPage.js, KnowledgeBasePage.js, CognitiveBiasTool.js: 根据后端API获取数据并展示。LoadingSpinner.js, Modal.js: 通用UI组件。5. MVP (最小可行产品) 核心功能实现顺序用户认证 (前后端): Firebase Auth 集成，后端Token验证和Firestore Profile创建。AI教练核心对话 (前后端):后端 coach_service.py 实现Gemini API调用和基本Prompt。后端 /api/coach/chat 和 /api/coach/history 接口。前端 CoachInterface.js 实现聊天UI和API调用。Firestore存储对话记录。简单的心智评估 (前后端，简化版):后端定义少量核心评估题目和简单评估逻辑。后端 /api/assessment/questions 和 /api/assessment/submit 接口。前端 AssessmentPage.js 实现问卷展示和提交。Firestore存储评估结果，并更新用户Profile。基础知识库展示 (后端提供数据，前端展示):后端 content_routes.py 提供 /api/kb/articles 接口从Firestore读取文章。前端 KnowledgeBasePage.js 展示文章列表和内容。6. 关键代码细节与提示错误处理： 前后端都需要完善的错误处理和用户反馈。安全性：后端：验证所有输入，防止注入等攻击。API Key等敏感信息使用环境变量。前端：避免XSS，注意依赖库安全。Firestore安全规则：务必配置Firestore安全规则，以保护用户数据。例如，用户只能读写自己的数据。// firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users can only read/write their own profile and subcollections
    match /artifacts/{appId}/users/{userId}/{document=**} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    // Public knowledge base can be read by anyone, written by admin (not shown here)
    match /artifacts/{appId}/public/data/knowledge_base/{articleId} {
      allow read: if true;
      allow write: if false; // Or implement admin role check
    }
  }
}
Prompt Engineering： coach_service.py 中的 generate_coach_response 函数是AI效果的核心。需要根据不同场景（日常对话、评估反馈、决策支持）精心设计和迭代Prompt。状态管理 (前端): 对于中型应用，考虑使用 Zustand 或 Redux Toolkit 简化状态管理，尤其是用户状态和AI教练对话状态。AuthContext 是一个好的开始。代码复用： 创建可复用的UI组件和服务函数。测试： 单元测试和服务集成测试。这份蓝图提供了一个相对完整的起点。在实际开发中，你会遇到更多细节问题，需要不断查阅文档、调试和迭代。祝你编码顺利！